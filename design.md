# offliner

## 后端服务

用 golang 启动 HTTP 服务，该服务可以：

- 解析短链接返回保存的网页
- 提供管理页面（该服务交互全部由 WEB 承载）
- 开机自启动
- 浏览器插件提取页面后将文件上传到后端
- 在桌面创建快捷方式，用于打开管理页面（或者以 webview 应用的形式）

## 交互

前后端分离，前端使用 angular(typescript) 制作静态页面

## 多端数据同步

不依赖中心化的数据同步服务，要同步数据可以将数据目录设置到同步盘

### 选型

用 sqlite 持久化数据，用日志跟踪最近操作

- 日志让多机可以并发操作不同的key。但同一个key，要确保操作的先后顺序，由此需要解决多机的时间同步问题（以用户最后一次操作为准，但还是可能有脏写）
- 组合 sqlite 查询（持久数据）和在内存中维护易于查询的数据结构（近期数据）

### 数据冲突

实际上，由于多机时间同步是不可能的(必须要有一个 modulator)，并且无法解决脏写，一般存储引擎都是单实例写，多实例读的模式

在我们多机写, 多机读的场景下, 特制定以下允许冲突的存储模式：

所有机器共享同一个 sqlite db 文件。

每个机器一个 wal 文件，该文件有与机器名相同的文件名，但还有一个唯一 id 号

每个机器只写自己的 wal 文件，每个 key 从版本 0 开始，每次操作也分配一个版本号，为基于的版本号+1，每次操作还有一个全局唯一的 id 号

如果同一个 key 从某一次操作开始，出现了多个版本号序列，就说明该 key 冲突，需要用户手动选择保留哪个版本，此时，就在解决冲突的机器执行操作：保留版本x(x为操作 id 号)

如果重复解决冲突, 即同时执行了保留版本x1, 和保留版本x2, 那该将 key 退回到冲突状态, 直到冲突解决, 所有机器同步到最新数据

### 持久化

持久化即将日志文件持久化至 sqlite db 文件

在多机情形下，我们需要协调由谁来负责持久化操作，以避免产生多个 db 文件造成文件冲突

#### 仅限单机操作

我们无法保证仅限单机操作，考虑多机系统中有一台机器长期离线，那么它与其他机器在这段时间形成了两个独立的分区，它可以把自己看成唯一的参与者，从而和另一个分区并行做出任何决策

#### 多机可操作

首先，考虑一下对于每台机器，只要条件满足就持久化是否可行

持久化的条件暂定为日志文件达到一定规模，这使得多台机器同时满足条件的概率降低

这种情况，依然存在两台机器同时执行持久化（网络分区时必然存在），因此，我们需要允许创建多个 sqlite db 文件，不过不用担心文件会持续增多，任何一个实例启动时，根据某种确定的规则删除多余的 sqlite db 文件即可

##### 日志剪裁

日志剪裁即对于已经持久化的操作版本以前的条目，可以全部删除以减少日志文件大小，节省空间、提高性能

删除多余的 sqlite db 文件将影响日志剪裁，由于单机不知道自己看到的 sqlite db 文件什么时候会被删，所以不敢贸然进行日志剪裁操作

一个解决方案如下：

删除 sqlite db 文件时需要确保安全性，如果无法安全地删除它，就在下次触发持久化时合并多个 sqlite db 文件（其实就是重新持久化一次）。

重新持久化后，需要删除旧文件，此时要注意正在使用的文件被删除问题。

#### 冲突 key 的持久化

每个 key 在持久化时都保存它上次持久化的版本 id 和本次最新的版本 id

这样就能区分一个 key 的冲突版本

但存在这样的情况, key1 在机器 A 持久化一次，在机器 B 持久化一次，而机器 A 上的 key1 版本小于机器 B 上的key1。最后，在 db 文件合并时，会将这两个 key 视为冲突的版本。

为解决这个问题，持久化一个 key 需要将它**所有**版本 id 保存下来，作为判断新旧版本的依据

单靠 { key, value, id } 的组合无法判断一个 key 是另一个 key 的老版本而不是冲突版本

#### 手动操作

#### 类 git 方式

每个机器维护独立的目录，里面包含 sqlite 数据文件和日志，实例启动时，读取自己的目录，然后尝试合并其他机器的数据文件

合并完成，写入sqlite，记录合并时所有机器版本号

合并过程中：
- 无冲突，直接写入
- 有冲突，保留自己的修改，保留其他机器的修改

不立即解决冲突：

写入冲突的版本，本机版本依然可以操作，也可以随时解决冲突

添加机器：

创建空目录，做一次合并即可

##### 降低数据同步频率和数据量

### 数据项

要保存的数据项有：

``` txt
文件数据：
    单文件网页 -- 只读文件，无同步问题
    
sqlite 数据：
    网页源地址
    离线访问用的短网址
    单文件网页文件名
```

## 网页保存

保存网页的技术要求

- 需要支持从浏览器插件保存，因为有些需要授权的内容 offliner 自身无法访问
- 可选保存为PDF，或者单文件HTML，提高整体可用性
- 保存的网页文件需要禁用掉查看时访问网络的能力
- 给每个保存的网页添加顶层快捷按钮，可直接修改、删除等，也可跳转至配置页

### 保存方案调研

https://github.com/puppeteer/puppeteer
- *.html + *_files 形式?
- 不会下载全部资源, 有些资源依然是url

https://github.com/gildas-lormeau/SingleFile
- 浏览器插件, 支持大多数浏览器
- 单页面保存
- 支持保存选定内容、选定frame
- 批量保存
- 注解、修改保存的网页
- 可保存至Google Drive，GitHub
- [已知问题列表](https://github.com/gildas-lormeau/SingleFile#known-issues)，看了下都是可接受的小问题
- 仍在维护，使用的项目也比较多

https://github.com/gildas-lormeau/single-file-cli
- SingleFile的命令行版本
- 单页面保存
- 需要docker, 或许能够可以脱离运行
- 脱离运行需要nodejs, 以及 Chrome 或 Firefox 或者jsdom
- 还在维护

https://github.com/zTrix/webpage2html
- 需要python
- 单页面保存
- 直接保存有无权限问题
- 先用浏览器保存, 再压缩成单文件的问题是: 浏览器不会下载某些资源
- 不支持less
- 不支持srcset
- [SATA协议](https://github.com/zTrix/webpage2html/blob/master/LICENSE.txt)
- 很久没维护了

https://github.com/markusmobius/nodeSavePageWE
- 依赖nodejs
- 单页面保存
- 从 Chrome SavePageWE 扩展改造, 可靠性不错
- 存在问题, 尚不确知
- 很久没维护了

综合对比，直接保存或借助浏览器保存，https://github.com/gildas-lormeau/single-file-cli都是最优选择

## 易用性

提出如下能提高软件易用性的建议：

- 可以配置自定义域名，通过修改 DNS 实现？
    - 修改 hosts 文件或者运行 DNS 服务会让用户感觉不安全，并且需要高权限
      - 我们无法监听 80 端口，访问时还是需要在域名后面指定端口，没有想象中简洁
    - 自定义协议跳转到 offliner 然后跳转到浏览器过于繁琐，而且自定义协议的链接一般无法被识别为链接
    - 最好直接拷贝 a 标签，实际链接为 localhost:port/abc 形式
- URL前添加 offline/ 快捷保存
- 支持批量保存
- 以后阅读和提醒支持

## 可靠性

保持几份数据文件备份

## 相似项目

- https://github.com/ArchiveBox/ArchiveBox
    - 没有多端同步支持
    - 没有浏览器插件保存授权内容
    - 过于复杂

- https://github.com/pjamar/htmls-to-datasette
    - 功能比较单一
  